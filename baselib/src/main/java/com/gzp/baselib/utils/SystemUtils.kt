package org.tianguang.baselib.utils

import android.annotation.TargetApi
import android.app.Activity
import android.app.ActivityManager
import android.content.ClipboardManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import android.graphics.Color
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.os.Process
import android.text.TextUtils
import android.view.View
import android.view.Window
import android.view.WindowManager
import android.view.inputmethod.InputMethodManager
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.gzp.baselib.utils.RomUtils
//import com.itheima.systembartint.SystemBarTintManager
import java.io.File
import java.io.FileInputStream
import java.io.IOException
import java.lang.reflect.Field
import java.util.*
import java.util.regex.Pattern

object SystemUtils {
    /**
     *
     * # begin build properties （开始设置系统性能）
     * # autogenerated （通过设置形成系统信息）
     * ro.=GRI40 (版本ID)
     * ro.build.=GRJ22 （版本号）
     * ro.build.version.incremental=eng.buildbot.20110619.060228 （版本增量）
     * ro.build.version.sdk=10 （sdk版本）
     * ro.build.version.codename=REL （版本代号）
     * ro.build.version.release=2.3.4 （Android 2.3.4系统）
     * ro.build.date=Sun Jun 19 06:02:58 UTC 2011 （制作者及制作时间）
     * ro.build.date.utc=0
     * ro.build.type=user (编译模式,如user,userdebug,eng,test模式)
     * ro.build.user=buildbot (编译账户)
     * ro.build.host=bb1 (编译主机系统)
     * ro.build.tags=test-keys (编译标签)
     * ro.product.model=HTC Wildfire （HTC内部手机代号）
     * ro.product.brand=htc_wwe （手机品牌）
     * ro.product.name=htc_buzz （手机正式名称）
     * ro.product.device=buzz （采用的设备）
     * ro.product.board=buzz （采用的处理器）
     * ro.product.cpu.abi=armeabi-v6j （cpu的版本）
     * ro.product.cpu.abi2=armeabi （cpu的品牌）
     * ro.product.manufacturer=HTC （手机制造商
     * ro.build.version.opporom
     * ro.vivo.os.version
     */
    const val SYS_EMUI = "sys_emui"
    const val SYS_MIUI = "sys_miui"
    const val SYS_FLYME = "sys_flyme"
    const val SYS_VIVO = "sys_vivo"
    const val SYS_OPPO = "sys_oppo"
    private const val KEY_MIUI_VERSION_CODE = "ro.miui.ui.version.code"
    private const val KEY_MIUI_VERSION_NAME = "ro.miui.ui.version.name"
    private const val KEY_MIUI_INTERNAL_STORAGE = "ro.miui.internal.storage"
    private const val KEY_EMUI_API_LEVEL = "ro.build.hw_emui_api_level"
    private const val KEY_EMUI_VERSION = "ro.build.version.emui"
    private const val KEY_EMUI_CONFIG_HW_SYS_VERSION = "ro.confg.hw_systemversion"
    private const val KEY_VIVO = "ro.vivo.os.version"
    private const val KEY_OPPO = "ro.build.version.opporom"//魅族//华为//小米//            e.printStackTrace();//魅族//oppo//vivo//华为

    //小米
    @JvmStatic
    val system: String?
        get() {
            var SYS: String? = null
            try {
                val prop = Properties()
                prop.load(FileInputStream(File(Environment.getRootDirectory(), "build.prop")))
                if (prop.getProperty(KEY_MIUI_VERSION_CODE, null) != null || prop.getProperty(KEY_MIUI_VERSION_NAME, null) != null || prop.getProperty(KEY_MIUI_INTERNAL_STORAGE, null) != null) {
                    SYS = SYS_MIUI //小米
                } else if (prop.getProperty(KEY_EMUI_API_LEVEL, null) != null || prop.getProperty(KEY_EMUI_VERSION, null) != null || prop.getProperty(KEY_EMUI_CONFIG_HW_SYS_VERSION, null) != null) {
                    SYS = SYS_EMUI //华为
                } else if (prop.getProperty(KEY_VIVO, null) != null) { //vivo
                    SYS = SYS_VIVO
                } else if (prop.getProperty(KEY_OPPO, null) != null) { //oppo
                    SYS = SYS_OPPO
                } else if (meizuFlymeOSFlag.toLowerCase().contains("flyme")) {
                    SYS = SYS_FLYME //魅族
                }
            } catch (e: IOException) {
//            e.printStackTrace();
                if (!TextUtils.isEmpty(getSystemProperty(KEY_MIUI_VERSION_CODE, ""))
                        || !TextUtils.isEmpty(getSystemProperty(KEY_MIUI_VERSION_NAME, ""))
                        || !TextUtils.isEmpty(getSystemProperty(KEY_MIUI_INTERNAL_STORAGE, ""))) {
                    SYS = SYS_MIUI //小米
                } else if (!TextUtils.isEmpty(getSystemProperty(KEY_EMUI_API_LEVEL, ""))
                        || !TextUtils.isEmpty(getSystemProperty(KEY_EMUI_VERSION, ""))
                        || !TextUtils.isEmpty(getSystemProperty(KEY_EMUI_CONFIG_HW_SYS_VERSION, ""))) {
                    SYS = SYS_EMUI //华为
                } else if (meizuFlymeOSFlag.toLowerCase().contains("flyme")) {
                    SYS = SYS_FLYME //魅族
                } else if (!TextUtils.isEmpty(getSystemProperty(KEY_VIVO, ""))) {
                    SYS = SYS_VIVO
                } else if (!TextUtils.isEmpty(getSystemProperty(KEY_OPPO, ""))) {
                    SYS = KEY_OPPO
                }
                return SYS
            }
            return SYS
        }

    val meizuFlymeOSFlag: String
        get() = getSystemProperty("ro.build.display.id", "")

    private fun getSystemProperty(key: String, defaultValue: String): String {
        try {
            val clz = Class.forName("android.os.SystemProperties")
            val get = clz.getMethod("get", String::class.java, String::class.java)
            return get.invoke(clz, key, defaultValue) as String
        } catch (e: Exception) {
        }
        return defaultValue
    }

    /**
     * 复制链接
     * @return
     */
    fun copyLink(context: Context?, content: String?) {
        val cm = context!!.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        cm.text = content
        Toast.makeText(context!!, "复制链接成功", Toast.LENGTH_SHORT).show()
    }

    fun copyLink(context: Context?, content: String?, tip: String?) {
        val cm = context!!.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        cm.text = content
        if (tip == null) {
            Toast.makeText(context!!, "复制成功", Toast.LENGTH_SHORT).show()
        } else {
            if (tip == "") {
                Toast.makeText(context!!, "复制成功", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(context!!, tip, Toast.LENGTH_SHORT).show()
            }
        }
    }

    fun getVersionCode(context: Context): Int {
        val packageManager = context.packageManager
        val packageInfo: PackageInfo
        var versionCode = 1
        try {
            packageInfo = packageManager.getPackageInfo(context.packageName, 0)
            versionCode = packageInfo.versionCode
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace()
        }
        return versionCode
    }

    fun getVersionName(context: Context): String {
        val packageManager = context.packageManager
        val packageInfo: PackageInfo
        var versionName = "1.0.0"
        try {
            packageInfo = packageManager.getPackageInfo(context.packageName, 0)
            versionName = packageInfo.versionName
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace()
        }
        return versionName
    }

    /**
     * 强制显示软键盘
     */
    fun forcedShowInput(context: Context?, view: View?) {
        val imm = context!!.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
        imm.showSoftInput(view, InputMethodManager.SHOW_FORCED)
    }

    /**
     * 显示软键盘（根据焦点所在的控件）
     */
    fun showSoftInput(context: Context) {
        (context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager).toggleSoftInput(InputMethodManager.SHOW_FORCED, 0)
    }

    /**
     * 关闭软键盘
     */
    fun closeSoftInput(context: Activity) {
        if (context.currentFocus != null) {
            (context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager)
                    .hideSoftInputFromWindow(context.currentFocus!!
                            .windowToken,
                            InputMethodManager.HIDE_NOT_ALWAYS)
        }
    }

    val sDKVersionNumber: Int
        get() {
            val sdkVersion: Int
            sdkVersion = try {
                Integer.valueOf(Build.VERSION.SDK)
            } catch (e: NumberFormatException) {
                0
            }
            return sdkVersion
        }



    fun isMobile(number: String?): Boolean {
        val p = Pattern.compile("^((17[0-9])|(14[0-9])|(13[0-9])|(15[0-9])|(18[0-9]))\\d{8}$")
        val m = p.matcher(number)
        return if (TextUtils.isEmpty(number)) {
            false
        } else m.matches()
    }

    fun fomatPrice(price: String): String {
        if (!TextUtils.isEmpty(price)) {
            val dotIndex = price.indexOf(".") + 1
            return if (dotIndex > 0) {
                if (price.length >= dotIndex + 2) {
                    price.substring(0, dotIndex + 2)
                } else {
                    price + "0"
                }
            } else {
                "$price.00"
            }
        }
        return price
    }

    fun callPhone(phone: String, context: Context) {
        val intent = Intent(Intent.ACTION_DIAL, Uri.parse("tel:$phone"))
        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
        context.startActivity(intent)
    }

    fun getPackageInfo(ctx: Context): PackageInfo {
        var info: PackageInfo? = null
        try {
            info = ctx.packageManager.getPackageInfo(ctx.packageName, 0)
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace(System.err)
        }
        if (info == null) info = PackageInfo()
        return info
    }

    fun isNamedProcess(context: Context?, processName: String): Boolean {
        if (context == null) {
            return false
        }
        val pid = Process.myPid()
        val manager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val processInfoList = manager.runningAppProcesses ?: return true
        for (processInfo in manager.runningAppProcesses) {
            if (processInfo.pid == pid && processInfo.processName == processName) {
                return true
            }
        }
        return false
    }

    fun isApplicationInBackground(context: Context): Boolean {
        val am = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val taskList = am.getRunningTasks(1)
        if (taskList != null && !taskList.isEmpty()) {
            val topActivity = taskList[0].topActivity
            if (topActivity != null && topActivity.packageName != context.packageName) {
                return true
            }
        }
        return false
    }

    /**
     * 修改状态栏为全透明
     * @param window
     */
    fun transparencyBar(window: Window) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            if (MIUISetStatusBarLightMode(window, true)) {
                window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)
            } else if (FlymeSetStatusBarLightMode(window, true)) {
                window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)
            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS or WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION)
                window.decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                        or View.SYSTEM_UI_FLAG_LAYOUT_STABLE)
                window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)
                window.statusBarColor = Color.TRANSPARENT
            }
        }
    }

    fun supportStatusBarLightMode(context: Context): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            val window = (context as AppCompatActivity).window
            if (MIUISetStatusBarLightMode(window, true)
                    || FlymeSetStatusBarLightMode(window, true)
                    || Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                return true
            }
        }
        return false
    }

    fun supportStatusBarLightMode(window: Window?): Boolean {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            if (MIUISetStatusBarLightMode(window, true)
                    || FlymeSetStatusBarLightMode(window, true)
                    || Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                return true
            }
        }
        return false
    }

    /**
     * 设置状态栏黑色字体图标，
     * 适配4.4以上版本MIUIV、Flyme和6.0以上版本其他Android
     *
     * @param window
     * @return 1:MIUUI 2:Flyme 3:android6.0
     */
    fun StatusBarLightMode(window: Window): Int {
        var result = 0
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            if (MIUISetStatusBarLightMode(window, true)) {
                result = 1
            } else if (FlymeSetStatusBarLightMode(window, true)) {
                result = 2
            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
                result = 3
            }
        }
        return result
    }

    fun StatusBarDarkMode(window: Window): Int {
        var result = 0
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            if (MIUISetStatusBarLightMode(window, false)) {
                result = 1
            } else if (FlymeSetStatusBarLightMode(window, false)) {
                result = 2
            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_VISIBLE
                result = 3
            }
        }
        return result
    }

    /**
     * 已知系统类型时，设置状态栏黑色字体图标。
     * 适配4.4以上版本MIUIV、Flyme和6.0以上版本其他Android
     *
     * @param window
     * @param type   1:MIUUI 2:Flyme 3:android6.0
     */
    fun StatusBarLightMode(window: Window, type: Int) {
        if (type == 1) {
            MIUISetStatusBarLightMode(window, true)
        } else if (type == 2) {
            FlymeSetStatusBarLightMode(window, true)
        } else if (type == 3) {
            window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
        }
    }

    /**
     * 清除MIUI或flyme或6.0以上版本状态栏黑色字体
     */
    fun StatusBarDarkMode(window: Window, type: Int) {
        if (type == 1) {
            MIUISetStatusBarLightMode(window, false)
        } else if (type == 2) {
            FlymeSetStatusBarLightMode(window, false)
        } else if (type == 3) {
            window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_VISIBLE
        }
    }

    /**
     * 设置状态栏图标为深色和魅族特定的文字风格
     * 可以用来判断是否为Flyme用户
     *
     * @param window 需要设置的窗口
     * @param dark   是否把状态栏字体及图标颜色设置为深色
     * @return boolean 成功执行返回true
     */
    fun FlymeSetStatusBarLightMode(window: Window?, dark: Boolean): Boolean {
        var result = false
        if (window != null) {
            try {
                val lp = window.attributes
                val darkFlag = WindowManager.LayoutParams::class.java
                        .getDeclaredField("MEIZU_FLAG_DARK_STATUS_BAR_ICON")
                val meizuFlags = WindowManager.LayoutParams::class.java
                        .getDeclaredField("meizuFlags")
                darkFlag.isAccessible = true
                meizuFlags.isAccessible = true
                val bit = darkFlag.getInt(null)
                var value = meizuFlags.getInt(lp)
                value = if (dark) {
                    value or bit
                } else {
                    value and bit.inv()
                }
                meizuFlags.setInt(lp, value)
                window.attributes = lp
                result = true
            } catch (e: Exception) {
            }
        }
        return result
    }

    /**
     * 设置状态栏字体图标为深色，需要MIUIV6以上
     *
     * @param window 需要设置的窗口
     * @param dark   是否把状态栏字体及图标颜色设置为深色
     * @return boolean 成功执行返回true
     */
    fun MIUISetStatusBarLightMode(window: Window?, dark: Boolean): Boolean {
        var result = false
        if (window != null) {
            val clazz: Class<*> = window.javaClass
            try {
                var darkModeFlag = 0
                val layoutParams = Class.forName("android.view.MiuiWindowManager\$LayoutParams")
                val field = layoutParams.getField("EXTRA_FLAG_STATUS_BAR_DARK_MODE")
                darkModeFlag = field.getInt(layoutParams)
                val extraFlagField = clazz.getMethod("setExtraFlags", Int::class.javaPrimitiveType, Int::class.javaPrimitiveType)
                if (dark) {
                    extraFlagField.invoke(window, darkModeFlag, darkModeFlag) //状态栏透明且黑色字体
                } else {
                    extraFlagField.invoke(window, 0, darkModeFlag) //清除黑色字体
                }
                result = true
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                    //开发版 7.7.13 及以后版本采用了系统API，旧方法无效但不会报错，所以两个方式都要加上
                    if (dark) {
                        window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
                    } else {
                        window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_VISIBLE
                    }
                }
            } catch (e: Exception) {
            }
        }
        return result
    }

    /**
     * 获取手机最顶层activity 类名字
     *
     * @param context
     * @return
     */
    fun getTopActivity(context: Context): String? {
        val manager = context.getSystemService(AppCompatActivity.ACTIVITY_SERVICE) as ActivityManager
        val runningTaskInfos = manager.getRunningTasks(1)
        return if (runningTaskInfos != null) runningTaskInfos[0].topActivity!!.className else null
    }

    fun getStatusBarHeight(context: Context): Int {
        val resourceId = context.resources.getIdentifier("status_bar_height", "dimen", "android")
        return context.resources.getDimensionPixelSize(resourceId)
    }

    fun getNavigationBarHeight(context: Context): Int {
        val resourceId = context.resources.getIdentifier("navigation_bar_height", "dimen", "android")
        return context.resources.getDimensionPixelSize(resourceId)
    }

    fun checkDeviceHasNavigationBar(context: Context): Boolean {
        var hasNavigationBar = false
        val rs = context.resources
        val id = rs.getIdentifier("config_showNavigationBar", "bool", "android")
        if (id > 0) {
            hasNavigationBar = rs.getBoolean(id)
        }
        try {
            val systemPropertiesClass = Class.forName("android.os.SystemProperties")
            val m = systemPropertiesClass.getMethod("get", String::class.java)
            val navBarOverride = m.invoke(systemPropertiesClass, "qemu.hw.mainkeys") as String
            if ("1" == navBarOverride) {
                hasNavigationBar = false
            } else if ("0" == navBarOverride) {
                hasNavigationBar = true
            }
        } catch (e: Exception) {
        }
        return hasNavigationBar
    }

    /**
     * 获取当前栈顶activity， 5.x
     *
     * @param context
     * @return
     */
    fun getCurrentPkgName(context: Context): String? {
        val START_TASK_TO_FRONT = 2
        var field: Field? = null
        try {
            field = ActivityManager.RunningAppProcessInfo::class.java.getDeclaredField("processState") //通过反射获取进程状态字段.
        } catch (e: Exception) {
            e.printStackTrace()
        }
        val manager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        val runningAppProcesses = manager.runningAppProcesses
        var currentInfo: ActivityManager.RunningAppProcessInfo? = null
        for (i in runningAppProcesses.indices) {
            val process = runningAppProcesses[i]
            if (process.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                // 前台运行进程
                var state: Int? = null
                try {
                    state = field!!.getInt(process) //反射调用字段值的方法,获取该进程的状态.
                } catch (e: Exception) {
                    e.printStackTrace()
                }
                if (state != null && state == START_TASK_TO_FRONT) {
                    currentInfo = process
                    break
                }
            }
        }
        var pkgName: String? = null
        if (currentInfo != null) {
            pkgName = currentInfo.processName
        }
        return pkgName
    }

    fun generateViewId(): Int {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
            View.generateViewId()
        } else {
            UUID.randomUUID().hashCode()
        }
    }

    /**
     * 修改状态栏颜色，支持4.4以上版本
     * @param activity
     * @param colorId
     */
    fun setStatusBarColor(activity: AppCompatActivity, colorId: Int) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            val window = activity.window
            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)
            window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)
            if (colorId != 0) window.statusBarColor = colorId
        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            //使用SystemBarTint库使4.4版本状态栏变色，需要先将状态栏设置为透明
            transparencyBar(activity)
//            val tintManager = SystemBarTintManager(activity)
//            tintManager.isStatusBarTintEnabled = true
//            if (colorId != 0) tintManager.setStatusBarTintResource(colorId)
        }
    }

    private fun setAndroidNativeLightStatusBar(activity: AppCompatActivity, dark: Boolean) {
        val decor = activity.window.decorView
        if (dark) {
            decor.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
        } else {
            decor.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE
        }
    }

    fun MIUISetStatusBarLightMode(activity: AppCompatActivity, dark: Boolean): Boolean {
        var result = false
        val window = activity.window
        if (window != null) {
            val clazz: Class<*> = window.javaClass
            try {
                var darkModeFlag = 0
                val layoutParams = Class.forName("android.view.MiuiWindowManager\$LayoutParams")
                val field = layoutParams.getField("EXTRA_FLAG_STATUS_BAR_DARK_MODE")
                darkModeFlag = field.getInt(layoutParams)
                val extraFlagField = clazz.getMethod("setExtraFlags", Int::class.javaPrimitiveType, Int::class.javaPrimitiveType)
                if (dark) {
                    extraFlagField.invoke(window, darkModeFlag, darkModeFlag) //状态栏透明且黑色字体
                } else {
                    extraFlagField.invoke(window, 0, darkModeFlag) //清除黑色字体
                }
                result = true
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && RomUtils.isMiUIV7OrAbove) {
                    //开发版 7.7.13 及以后版本采用了系统API，旧方法无效但不会报错，所以两个方式都要加上
                    if (dark) {
                        activity.window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR
                    } else {
                        activity.window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                    }
                }
            } catch (e: Exception) {
            }
        }
        return result
    }

    private fun setFlymeLightStatusBar(activity: AppCompatActivity?, dark: Boolean): Boolean {
        var result = false
        if (activity != null) {
            try {
                val lp = activity.window.attributes
                val darkFlag = WindowManager.LayoutParams::class.java
                        .getDeclaredField("MEIZU_FLAG_DARK_STATUS_BAR_ICON")
                val meizuFlags = WindowManager.LayoutParams::class.java
                        .getDeclaredField("meizuFlags")
                darkFlag.isAccessible = true
                meizuFlags.isAccessible = true
                val bit = darkFlag.getInt(null)
                var value = meizuFlags.getInt(lp)
                value = if (dark) {
                    value or bit
                } else {
                    value and bit.inv()
                }
                meizuFlags.setInt(lp, value)
                activity.window.attributes = lp
                result = true
            } catch (e: Exception) {
            }
        }
        return result
    }

    @TargetApi(19)
    fun transparencyBar(activity: AppCompatActivity) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            val window = activity.window
            window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)
            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)
            window.decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                    or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN)
            window.statusBarColor = Color.TRANSPARENT
        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            val window = activity.window
            window.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,
                    WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)
        }
    }

    /**
     * 修改状态栏文字颜色，这里小米，魅族区别对待。
     */
    fun setLightStatusBar(activity: AppCompatActivity, dark: Boolean) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            when (RomUtils.lightStatusBarAvailableRomType) {
                RomUtils.AvailableRomType.MIUI -> MIUISetStatusBarLightMode(activity, dark)
                RomUtils.AvailableRomType.FLYME -> setFlymeLightStatusBar(activity, dark)
                RomUtils.AvailableRomType.ANDROID_NATIVE -> setAndroidNativeLightStatusBar(activity, dark)
            }
        }
    }
}